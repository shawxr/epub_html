
        <html lang="en">
        <head>
        <meta charset="UTF-8"/>
        </head>
        <body>
        <div><div class="readable-text" data-hash="4d7486490f59c7cfe01d6ad206d59133" data-text-hash="30056947c059e71e501e712d6f744f4d" id="1" refid="1">
<h1>1 Introducing Kubernetes</h1>
</div>
<div class="introduction-summary">
<h3 class="intro-header">This chapter covers</h3>
<ul>
<li class="readable-text" data-hash="ffc0bc7d9c6125dcbde592381c37761f" data-text-hash="ffc0bc7d9c6125dcbde592381c37761f" id="2" refid="2">Introductory information about Kubernetes and its origins</li>
<li class="readable-text" data-hash="26abec6b82249a2d58f4a07b42629187" data-text-hash="26abec6b82249a2d58f4a07b42629187" id="3" refid="3">Why Kubernetes has seen such wide adoption</li>
<li class="readable-text" data-hash="4317ca79720ae423472864b84482866a" data-text-hash="4317ca79720ae423472864b84482866a" id="4" refid="4">How Kubernetes transforms your data center</li>
<li class="readable-text" data-hash="611bfd1a32f1c45cff2f21784e23a4a6" data-text-hash="611bfd1a32f1c45cff2f21784e23a4a6" id="5" refid="5">An overview of its architecture and operation</li>
<li class="readable-text" data-hash="740847105be18e8fa3ef37fce9837fe9" data-text-hash="740847105be18e8fa3ef37fce9837fe9" id="6" refid="6">How and if you should integrate Kubernetes into your own organization</li>
</ul>
</div>
<div class="readable-text" data-hash="d05a845f455f8bb42c682ffacc8c7e7c" data-text-hash="a6e40c976456d984a1b8e2272e1abd8f" id="7" refid="7">
<p>Before you can learn about the ins and outs of running applications with Kubernetes, you must first gain a basic understanding of the problems Kubernetes is designed to solve, how it came about, and its impact on application development and deployment. This first chapter is intended to give a general overview of these topics.</p>
</div>
<div class="readable-text" data-hash="88f6d8e7f43b7d41eec77a31ec84d7ed" data-text-hash="f0cce2de5c717c2c799915afc939f81c" id="8" refid="8">
<h2 id="sigil_toc_id_2">1.1&#160;Introducing Kubernetes</h2>
</div>
<div class="readable-text" data-hash="528e7701d2949039da993f1d30506267" data-text-hash="bf02a7d552a81798bd728687779f88e5" id="9" refid="9">
<p>The word <i>Kubernetes</i> is Greek for pilot or helmsman, the person who steers the ship - the person standing at the helm (the ship&#8217;s wheel). A helmsman is not necessarily the same as a captain. A captain is responsible for the ship, while the helmsman is the one who steers it.</p>
</div>
<div class="readable-text" data-hash="f4c9329ab92e2dc953792dd88ab1de62" data-text-hash="2c6ccfea5525ed4ff18f8bbadcf122e1" id="10" refid="10">
<p>After learning more about what Kubernetes does, you&#8217;ll find that the name hits the spot perfectly. A helmsman maintains the course of the ship, carries out the orders given by the captain and reports back the ship's heading. Kubernetes steers your applications and reports on their status while you - the captain - decide where you want the system to go.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" data-hash="6d430ad88335e3e4b189f660474826f4" data-text-hash="cd2c2388a71560db451236c62f4cd43c" id="11" refid="11">
<h5>How to pronounce Kubernetes and what is k8s?</h5>
</div>
<div class="readable-text" data-hash="a8ee4c3ab893a3bf567d7062ce97e564" data-text-hash="981c403d0abc456fd54791a22cb87aab" id="12" refid="12">
<p>The correct Greek pronunciation of Kubernetes, which is <i>Kie-ver-nee-tees</i>, is different from the English pronunciation you normally hear in technical conversations. Most often it&#8217;s <i>Koo-ber-netties</i> or <i>Koo-ber-nay&#8217;-tace</i>, but you may also hear <i>Koo-ber-nets</i>, although rarely.</p>
</div>
<div class="readable-text" data-hash="e1198668861efbf8d5d525912f329c05" data-text-hash="4adc26a03afb22d2510cd9802b9e92d6" id="13" refid="13">
<p>In both written and oral conversations, it&#8217;s also referred to as <i>Kube</i> or <i>K8s,</i> pronounced <i>Kates</i>, where the 8 signifies the number of letters omitted between the first and last letter.</p>
</div>
</div>
<div class="readable-text" data-hash="bd51666ece411c33be24804696bdb38f" data-text-hash="2a10181042862a6490dee940b0cc738a" id="14" refid="14">
<h3 id="sigil_toc_id_3">1.1.1&#160;&#160; Kubernetes in a nutshell</h3>
</div>
<div class="readable-text" data-hash="8a38bdc9bfaa75a2d547fc5d106d3888" data-text-hash="3e1438b0ef829d8b1a5f157f049bf1ae" id="15" refid="15">
<p>Kubernetes is a software system for automating the deployment and management of complex, large-scale application systems composed of computer processes running in containers. Let&#8217;s learn what it does and how it does it.</p>
</div>
<div class="readable-text" data-hash="9aeab8f051b3b78062e5b5dcacf756c5" data-text-hash="ed7f08f7502bcd086303f02dbfbb98a3" id="16" refid="16">
<h4>Abstracting away the infrastructure</h4>
</div>
<div class="readable-text" data-hash="1adb591e32a40fd87c05922c92a4beec" data-text-hash="2ebd4ec5b15afc59fa0de0a5e1c96305" id="17" refid="17">
<p>When software developers or operators decide to deploy an application, they do this through Kubernetes instead of deploying the application to individual computers. Kubernetes provides an abstraction layer over the underlying hardware to both users and applications.</p>
</div>
<div class="readable-text" data-hash="f19eec46e37721bcd62c7368469d6a1c" data-text-hash="1540397db2f8f98db1e62a244d9b9e35" id="18" refid="18">
<p>As you can see in the following figure, the underlying infrastructure, meaning the computers, the network and other components, is hidden from the applications, making it easier to develop and configure them.</p>
</div>
<div class="browsable-container figure-container" data-hash="a1737a11250491110531e10aa0270af2" data-text-hash="2af794ac0dad8f371b25b6b8a6147f24" id="19" refid="19">
<h5>Figure 1.1 Infrastructure abstraction using Kubernetes</h5>
<img alt="" data-processed="true" height="351" id="Picture_18" loading="lazy" src="EPUB/images/1.1.png" width="957">
</div>
<div class="readable-text" data-hash="9614d1613bf99e481f8dc15170710557" data-text-hash="3162db378685002e58fdf73d85c5528e" id="20" refid="20">
<h4>Standardizing how we deploy applications</h4>
</div>
<div class="readable-text" data-hash="6958edc2a554be566f8b4c8273f9b1c6" data-text-hash="85ecc2e40387220241b776b608552d33" id="21" refid="21">
<p>Because the details of the underlying infrastructure no longer affect the deployment of applications, you deploy applications to your corporate data center in the same way as you do in the cloud. A single manifest that describes the application can be used for local deployment and for deploying on any cloud provider. All differences in the underlying infrastructure are handled by Kubernetes, so you can focus on the application and the business logic it contains.</p>
</div>
<div class="readable-text" data-hash="7040b749f88759a5fb49b30102747f39" data-text-hash="465bc9a8431242cd7ffe88456c7babae" id="22" refid="22">
<h4>Deploying applications declaratively</h4>
</div>
<div class="readable-text" data-hash="838ae49094ccafb59bdfc1c4335f1db7" data-text-hash="db6b61a97cabac76840cb3aa60d91b27" id="23" refid="23">
<p>Kubernetes uses a declarative model to define an application, as shown in the next figure. You describe the components that make up your application and Kubernetes turns this description into a running application. It then keeps the application healthy by restarting or recreating parts of it as needed.</p>
</div>
<div class="browsable-container figure-container" data-hash="b109753b284f1ba92281382c937040ec" data-text-hash="ba804b2631b6268e50d09b9aa7938182" id="24" refid="24">
<h5>Figure 1.2 The declarative model of application deployment</h5>
<img alt="" data-processed="true" height="328" id="Picture_16" loading="lazy" src="EPUB/images/1.2.png" width="901">
</div>
<div class="readable-text" data-hash="0bbe627ce6c8abfcb5110e66af6cbf37" data-text-hash="32ed9c86f361c54a1d13cbdd9f7e12bd" id="25" refid="25">
<p>Whenever you change the description, Kubernetes will take the necessary steps to reconfigure the running application to match the new description, as shown in the next figure.</p>
</div>
<div class="browsable-container figure-container" data-hash="4735e66446adac29f6866e993a73d560" data-text-hash="3462779e79e9e79d8f0d59aba2c5a67b" id="26" refid="26">
<h5>Figure 1.3 Changes in the description are reflected in the running application</h5>
<img alt="" data-processed="true" height="325" id="Picture_19" loading="lazy" src="EPUB/images/1.3.png" width="944">
</div>
<div class="readable-text" data-hash="fdc57a3994e4581a37982c0e35b83c01" data-text-hash="f01b4784bcded9d7e0db00ea655262ae" id="27" refid="27">
<h4>Taking on the daily management of applications</h4>
</div>
<div class="readable-text" data-hash="5b1ce192ded0923ba94551064499640d" data-text-hash="2bdbfca4ae659540d9a2de3bb58d6480" id="28" refid="28">
<p>As soon as you deploy an application to Kubernetes, it takes over the daily management of the application. If the application fails, Kubernetes will automatically restart it. If the hardware fails or the infrastructure topology changes so that the application needs to be moved to other machines, Kubernetes does this all by itself. The engineers responsible for operating the system can focus on the big picture instead of wasting time on the details.</p>
</div>
<div class="readable-text" data-hash="f2063c7e74f3a4a967a05b909623d667" data-text-hash="99bc76ae3bc9cafaf3e4f564480a3f9f" id="29" refid="29">
<p>To circle back to the sailing analogy: the development and operations engineers are the ship&#8217;s officers who make high-level decisions while sitting comfortably in their armchairs, and Kubernetes is the helmsman who takes care of the low-level tasks of steering the system through the rough waters your applications and infrastructure sail through.</p>
</div>
<div class="browsable-container figure-container" data-hash="94c1b3a08b9cb9e9f4328a15cbb9279a" data-text-hash="350504ed467e0159f14b5dc005065ef2" id="30" refid="30">
<h5>Figure 1.4 Kubernetes takes over the management of applications</h5>
<img alt="" data-processed="true" height="336" loading="lazy" src="EPUB/images/1.4.png" width="774">
</div>
<div class="readable-text" data-hash="41f42a52bd7a9d6b455149ac7ebac511" data-text-hash="55d59d6c14a292c719c58ec1842a281d" id="31" refid="31">
<p>Everything that Kubernetes does and all the advantages it brings requires a longer explanation, which we&#8217;ll discuss later. Before we do that, it might help you to know how it all began and where the Kubernetes project currently stands.</p>
</div>
<div class="readable-text" data-hash="705e06fd0afc5d53756e58fdd400cebe" data-text-hash="6281ab227c33c98fb62835eac322f026" id="32" refid="32">
<h3 id="sigil_toc_id_4">1.1.2&#160;&#160; About the Kubernetes project</h3>
</div>
<div class="readable-text" data-hash="0c17e70d2d68277d907a879b1ec8795a" data-text-hash="ab2b7648d7257d26aa05a19e97bca463" id="33" refid="33">
<p>Kubernetes was originally developed by Google. Google has practically always run applications in containers. As early as 2014, it was reported that they start two billion containers every week. That&#8217;s over 3,000 containers per second, and the figure is much higher today. They run these containers on thousands of computers distributed across dozens of data centers around the world. Now imagine doing all this manually. It&#8217;s clear that you need automation, and at this massive scale, it better be perfect.</p>
</div>
<div class="readable-text" data-hash="76cecff8c95430e2f068472932f2f001" data-text-hash="9afe695871fb29d34dd42b68a42e8558" id="34" refid="34">
<h4>About Borg and Omega - the predecessors of Kubernetes</h4>
</div>
<div class="readable-text" data-hash="47d57f9bdb563d1eb44931d809099730" data-text-hash="ba4b0639eaf037addf604d368e6e56f5" id="35" refid="35">
<p>The sheer scale of Google&#8217;s workload has forced them to develop solutions to make the development and management of thousands of software components manageable and cost-effective. Over the years, Google developed an internal system called <i>Borg</i> (and later a new system called Omega) that helped both application developers and operators manage these thousands of applications and services.</p>
</div>
<div class="readable-text" data-hash="b35050986cc2398bce7543b67755eaf5" data-text-hash="05f9e158b6666fc2921a54f6ff6ffbaa" id="36" refid="36">
<p>In addition to simplifying development and management, these systems have also helped them to achieve better utilization of their infrastructure. This is important in any organization, but when you operate hundreds of thousands of machines, even tiny improvements in utilization mean savings in the millions, so the incentives for developing such a system are clear.</p>
</div>
<div class="callout-container fm-callout">
<div class="readable-text" data-hash="f35a087d0dc71beb3a7204d91c1c49e4" data-text-hash="3b0649c72650c313a357338dcdfb64ec" id="37" refid="37">
<h5>Note</h5>
</div>
<div class="readable-text" data-hash="76fe7638cd2364ebd9ce58be42ab92af" data-text-hash="8a262473447a7f86815d4efe4d3c0abd" id="38" refid="38">
<p> Data on Google&#8217;s energy use suggests that they run around 900,000 servers.</p>
</div>
</div>
<div class="readable-text" data-hash="ad41feba4a9b0fe905c77ca6a280b3ca" data-text-hash="21654ff244932a1cb623db24a8f44984" id="39" refid="39">
<p>Over time, your infrastructure grows and evolves. Every new data center is state-of-the-art. Its infrastructure differs from those built in the past. Despite the differences, the deployment of applications in one data center should not differ from deployment in another data center. This is especially important when you deploy your application across multiple zones or regions to reduce the likelihood that a regional failure will cause application downtime. To do this effectively, it&#8217;s worth having a consistent method for deploying your applications.</p>
</div>
<div class="readable-text" data-hash="a323dacc3766ebc2e045415a3260dac2" data-text-hash="783fe17e4b2c18f3515bec2713a0fe17" id="40" refid="40">
<h4>About Kubernetes - the open-source project - and commercial products derived from it</h4>
</div>
<div class="readable-text" data-hash="153b781bb3cd5a4e911701da851895ff" data-text-hash="12670981f39da70636b53b21a04d46c9" id="41" refid="41">
<p>Based on the experience they gained while developing Borg, Omega and other internal systems, in 2014 Google introduced Kubernetes, an open-source project that can now be used and further improved by everyone.</p>
</div>
<div class="browsable-container figure-container" data-hash="6bd8e0cfd861bd5432e8ba8615241bb5" data-text-hash="f7963fe47e3e8f9c1dc509c0e7829ec6" id="42" refid="42">
<h5>Figure 1.5 The origins and state of the Kubernetes open-source project</h5>
<img alt="" data-processed="true" height="276" id="Picture_21" loading="lazy" src="EPUB/images/1.5.png" width="962">
</div>
<div class="readable-text" data-hash="23c07534a20836cce79151a96e141ecd" data-text-hash="0d0fa7fce8a2fabba083a5673bc834af" id="43" refid="43">
<p>As soon as Kubernetes was announced, long before version 1.0 was officially released, other companies, such as Red Hat, who has always been at the forefront of open-source software, quickly stepped on board and helped develop the project. It eventually grew far beyond the expectations of its founders, and today is arguably one of the world&#8217;s leading open-source projects, with dozens of organizations and thousands of individuals contributing to it.</p>
</div>
<div class="readable-text" data-hash="f62937e4eb45596e7ce877fe7621aeca" data-text-hash="0095f90a2c792c04bdfa50be664d1f72" id="44" refid="44">
<p>Several companies are now offering enterprise-quality Kubernetes products that are built from the open-source project. These include Red Hat OpenShift, Pivotal Container Service, Rancher and many others.</p>
</div>
<div class="readable-text" data-hash="be6b4d5956ee94acad1d09453865dc37" data-text-hash="7ec3544f621d897f383e681c3a2fc53b" id="45" refid="45">
<h4>How Kubernetes grew a whole new cloud-native eco-system</h4>
</div>
<div class="readable-text" data-hash="1111d024db074ed25668b49053151005" data-text-hash="83498a8eb8a9ff40078488deb46ddbc4" id="46" refid="46">
<p>Kubernetes has also spawned many other related open-source projects, most of which are now under the umbrella of the <i>Cloud Native Computing Foundation</i> (CNCF), which is part of the <i>Linux Foundation</i>.</p>
</div>
<div class="readable-text" data-hash="24a70c86c8fb2ede5cafae6ba71a3d82" data-text-hash="c14d8eb4d88d3ce32fcc14917b289d16" id="47" refid="47">
<p>CNCF organizes several KubeCon - CloudNativeCon conferences per year - in North America, Europe and China. In 2019, the total number of attendees exceeded 23,000, with KubeCon North America reaching an overwhelming number of 12,000 participants. These figures show that Kubernetes has had an incredibly positive impact on the way companies around the world deploy applications today. It wouldn&#8217;t have been so widely adopted if that wasn&#8217;t the case.</p>
</div>
<div class="readable-text" data-hash="3424e62b5072bf2418fa74ec113fdaaa" data-text-hash="9f8d158cc6d8ead0b20990ae371181e1" id="48" refid="48">
<h3 id="sigil_toc_id_5">1.1.3&#160;&#160; Understanding why Kubernetes is so popular</h3>
</div>
<div class="readable-text" data-hash="694b3dfef66930fea708bc1e36f329fe" data-text-hash="e72db9bfaf0c3a4ba43949fc03340c23" id="49" refid="49">
<p>In recent years, the way we develop applications has changed considerably. This has led to the development of new tools like Kubernetes, which in turn have fed back and fuelled further changes in application architecture and the way we develop them. Let&#8217;s look at concrete examples of this.</p>
</div>
<div class="readable-text" data-hash="86ed9707f638cebf8fee28951e07d156" data-text-hash="aec8e0e14eba820e916248059503f33b" id="50" refid="50">
<h4>Automating the management of microservices</h4>
</div>
<div class="readable-text" data-hash="413a734b2945d48c964e74be0e16a4b0" data-text-hash="9c19094e459ba77b2f185e6f95550f29" id="51" refid="51">
<p>In the past, most applications were large monoliths. The components of the application were tightly coupled, and they all ran in a single computer process. The application was developed as a unit by a large team of developers and the deployment of the application was straightforward. You installed it on a powerful computer and provided the little configuration it required. Scaling the application horizontally was rarely possible, so whenever you needed to increase the capacity of the application, you had to upgrade the hardware - in other words, scale the application vertically.</p>
</div>
<div class="readable-text" data-hash="1453b3dac860e1738ca4c8742d3d6139" data-text-hash="7248a796b0a777c73d0e7aa07a64a7ee" id="52" refid="52">
<p>Then came the microservices paradigm. The monoliths were divided into dozens, sometimes hundreds, of separate processes, as shown in the following figure. This allowed organizations to divide their development departments into smaller teams where each team developed only a part of the entire system - just some of the microservices.</p>
</div>
<div class="browsable-container figure-container" data-hash="1c3fe989615d8980d07a6eab58474927" data-text-hash="88738922e7740c795759b4ddf9012970" id="53" refid="53">
<h5>Figure 1.6 Comparing monolithic applications with microservices</h5>
<img alt="" data-processed="true" height="282" id="Picture_15" loading="lazy" src="EPUB/images/1.6.png" width="959">
</div>
<div class="readable-text" data-hash="2e79f4c298ce867b7abb51f2414cdc8d" data-text-hash="ce46c901ca6e8b0dc21b4e4ede99ed2d" id="54" refid="54">
<p>Each microservice is now a separate application with its own development and release cycle. The dependencies of different microservices will inevitably diverge over time. One microservice requires one version of a library, while another microservice requires another, possibly incompatible, version of the same library. Running the two applications in the same operating system becomes difficult.</p>
</div>
<div class="readable-text" data-hash="9853a73d1ad74304d98ecf91919c2707" data-text-hash="885f481312d7ebe126dc5e31efab7f1c" id="55" refid="55">
<p>Fortunately, containers alone solve this problem where each microservice requires a different environment, but each microservice is now a separate application that must be managed individually. The increased number of applications makes this much more difficult.</p>
</div>
<div class="readable-text" data-hash="87b7c6cd6ac4a2725408088d41058e7c" data-text-hash="46c43f30c1aca842da1e46a09f4db517" id="56" refid="56">
<p>Individual parts of the entire application no longer need to run on the same computer, which makes it easier to scale the entire system, but also means that the applications need to be configured to communicate with each other. For systems with only a handful of components, this can usually be done manually, but it&#8217;s now common to see deployments with well over a hundred microservices.</p>
</div>
<div class="readable-text" data-hash="7142545c5d1dbdf47f3661b35dd8df0f" data-text-hash="d45e25eade5a4082fe5512da2c9d5371" id="57" refid="57">
<p>When the system consists of many microservices, automated management is crucial. Kubernetes provides this automation. The features it offers make the task of managing hundreds of microservices almost trivial.</p>
</div>
<div class="readable-text" data-hash="6f62722ec4bca18c2d27d690ddd9db97" data-text-hash="15f96003a21a3ebaf1cea329d1a05de2" id="58" refid="58">
<h4>Bridging the dev and ops divide</h4>
</div>
<div class="readable-text" data-hash="f19e95cbb09cc2ba4184bd3d1e425b40" data-text-hash="88eba61e89c55ee575d152cd1e03070c" id="59" refid="59">
<p>Along with these changes in application architecture, we&#8217;ve also seen changes in the way teams develop and run software. It used to be normal for a development team to build the software in isolation and then throw the finished product over the wall to the operations team, who would then deploy it and manage it from there.</p>
</div>
<div class="readable-text" data-hash="691ac0be5e406fe428d97fed93fa6566" data-text-hash="27d9347d7f90118956d008e2170e24c2" id="60" refid="60">
<p>With the advent of the Dev-ops paradigm, the two teams now work much more closely together throughout the entire life of the software product. The development team is now much more involved in the daily management of the deployed software. But that means that they now need to know about the infrastructure on which it&#8217;s running.</p>
</div>
<div class="readable-text" data-hash="450ac4e595022f9055898c6253df2085" data-text-hash="683ace8789962e67e6b2e95a20aa9c91" id="61" refid="61">
<p>As a software developer, your primary focus is on implementing the business logic. You don&#8217;t want to deal with the details of the underlying servers. Fortunately, Kubernetes hides these details.</p>
</div>
<div class="readable-text" data-hash="39d32939bd2936228cfa38245b93c7f2" data-text-hash="54035bcd7fa03ef37377e234748ef15b" id="62" refid="62">
<h4>Standardizing the cloud</h4>
</div>
<div class="readable-text" data-hash="3624bcf383b99ff6560d966f68dac53a" data-text-hash="78f3968bf8d4ba12ee4ba7ee14b407da" id="63" refid="63">
<p>Over the past decade or two, many organizations have moved their software from local servers to the cloud. The benefits of this seem to have outweighed the fear of being locked-in to a particular cloud provider, which is caused by relying on the provider&#8217;s proprietary APIs to deploy and manage applications.</p>
</div>
<div class="readable-text" data-hash="7b0660ead20fd02731f7bab479512886" data-text-hash="dd82ae344da22436f07ff5324e922261" id="64" refid="64">
<p>Any company that wants to be able to move its applications from one provider to another will have to make additional, initially unnecessary efforts to abstract the infrastructure and APIs of the underlying cloud provider from the applications. This requires resources that could otherwise be focused on building the primary business logic.</p>
</div>
<div class="readable-text" data-hash="05465ef710c833fddb910233208556fb" data-text-hash="8ac2359cf9c7da85196e8e3f2b8e6552" id="65" refid="65">
<p>Kubernetes has also helped in this respect. The popularity of Kubernetes has forced all major cloud providers to integrate Kubernetes into their offerings. Customers can now deploy applications to any cloud provider through a standard set of APIs provided by Kubernetes.</p>
</div>
<div class="browsable-container figure-container" data-hash="ce9d7ca27a13fa77582b289e073f6066" data-text-hash="60f000c1cb6bd77ef13b1d0478d7de6e" id="66" refid="66">
<h5>Figure 1.7 Kubernetes has standardized how you deploy applications on cloud providers</h5>
<img alt="" data-processed="true" height="249" id="Picture_23" loading="lazy" src="EPUB/images/1.7.png" width="961">
</div>
<div class="readable-text" data-hash="6b9d91e1bdcb1a9f1a8fa52d6717361e" data-text-hash="0e67c2c1aee21f92f608b9ec27031c04" id="67" refid="67">
<p>If the application is built on the APIs of Kubernetes instead of directly on the proprietary APIs of a specific cloud provider, it can be transferred relatively easily to any other provider.</p>
</div>
<div class="readable-text" data-hash="8f1b74ecebaaf60f5691546133974a80" data-text-hash="b8672646ba8b79ebe3a2bd3ef61c4501" id="68" refid="68">
<h2 id="sigil_toc_id_6">1.2&#160;Understanding Kubernetes</h2>
</div>
<div class="readable-text" data-hash="aa28ba48fb3e66ed8556c14848f97939" data-text-hash="407f40490242f215c40ed669f11ecc57" id="69" refid="69">
<p>The previous section explained the origins of Kubernetes and the reasons for its wide adoption. In this section we&#8217;ll take a closer look at what exactly Kubernetes is.</p>
</div>
<div class="readable-text" data-hash="ed29713688009066eb6bbcd71abcfb6f" data-text-hash="a512eba422d2d2b3505e8164d3e66ec0" id="70" refid="70">
<h3 id="sigil_toc_id_7">1.2.1&#160;&#160; Understanding how Kubernetes transforms a computer cluster</h3>
</div>
<div class="readable-text" data-hash="0ba3f1d77c82df0856254fe089d60458" data-text-hash="25ec89d910866cecad97504d5806fb1b" id="71" refid="71">
<p>Let&#8217;s take a closer look at how the perception of the data center changes when you deploy Kubernetes on your servers.</p>
</div>
<div class="readable-text" data-hash="c6ba6b511e02a78c7c51a4ab5464582a" data-text-hash="d5f13ca0347afc066515977a06ba4dd0" id="72" refid="72">
<h4>Kubernetes is like an operating system for computer clusters</h4>
</div>
<div class="readable-text" data-hash="784f8cdbcfb648e676bbbc38b33b9929" data-text-hash="5b162ab7785bdec39ce696e0b3074e1f" id="73" refid="73">
<p>One can imagine Kubernetes as an operating system for the cluster. The next figure illustrates the analogies between an operating system running on a computer and Kubernetes running on a cluster of computers.</p>
</div>
<div class="browsable-container figure-container" data-hash="37e47e0e9e781c3c4b3cd6e3d830d82b" data-text-hash="7d58776da09f3e264b64f613ce91f531" id="74" refid="74">
<h5>Figure 1.8 Kubernetes is to a computer cluster what an Operating System is to a computer</h5>
<img alt="" data-processed="true" height="245" id="Picture_24" loading="lazy" src="EPUB/images/1.8.png" width="955">
</div>
<div class="readable-text" data-hash="14bae2ec4689adf973b2e423f77b956d" data-text-hash="bd6990acd6dd9bc3eb8e69d8d692f93e" id="75" refid="75">
<p>Just as an operating system supports the basic functions of a computer, such as scheduling processes onto its CPUs and acting as an interface between the application and the computer&#8217;s hardware, Kubernetes schedules the components of a distributed application onto individual computers in the underlying computer cluster and acts as an interface between the application and the cluster.</p>
</div>
<div class="readable-text" data-hash="20a4402473eb331c6c9159bed53d7c94" data-text-hash="87fe3283ec40c3c5eca8d8a426fdbd17" id="76" refid="76">
<p>It frees application developers from the need to implement infrastructure-related mechanisms in their applications; instead, they rely on Kubernetes to provide them. This includes things like:</p>
</div>
<ul>
<li class="readable-text" data-hash="c3c463781a89bfe2a4816d61264bcb8c" data-text-hash="175c39df1e21d0b0e61003977e4bbab3" id="77" refid="77"><i>service discovery</i> - a mechanism that allows applications to find other applications and use the services they provide,</li>
<li class="readable-text" data-hash="52fd824fde810cbb887db917b9d924e2" data-text-hash="cc7ca7feea1aeeebbc43ecfd7ed7454c" id="78" refid="78"><i>horizontal scaling</i> - replicating your application to adjust to fluctuations in load,</li>
<li class="readable-text" data-hash="65bfe27677dd3ffcfdf15cca25b970ad" data-text-hash="ef9b2228e336d2b8d3582ea0e58d26c9" id="79" refid="79"><i>load-balancing</i> - distributing load across all the application replicas,</li>
<li class="readable-text" data-hash="26e3625634eacaab7497ddd4c43643b8" data-text-hash="79bb01c024d0231354abdbfd1cab89aa" id="80" refid="80"><i>self-healing</i> - keeping the system healthy by automatically restarting failed applications and moving them to healthy nodes after their nodes fail,</li>
<li class="readable-text" data-hash="81296956edc5ab6035d5274bdee5717c" data-text-hash="1191b02bc758494a8c96e5e7aa689295" id="81" refid="81"><i>leader election</i> - a mechanism that decides which instance of the application should be active while the others remain idle but ready to take over if the active instance fails.</li>
</ul>
<div class="readable-text" data-hash="8b74b2c1fc92a4c421a47a7ea1e00e51" data-text-hash="f244ebe5b2fb9e4dcf6c07d988b683cb" id="82" refid="82">
<p>By relying on Kubernetes to provide these features, application developers can focus on implementing the core business logic instead of wasting time integrating applications with the infrastructure.</p>
</div>
<div class="readable-text" data-hash="ca0373c811fb107ccede8fdd9ca8303f" data-text-hash="f1586e89e88197457d8e8a7dfd52c472" id="83" refid="83">
<h4>How Kubernetes fits into a computer cluster</h4>
</div>
<div class="readable-text" data-hash="fdfff5b26b7408077748559cbb2cf83f" data-text-hash="edba58529f53c8094d49f6b7fcdad03c" id="84" refid="84">
<p>To get a concrete example of how Kubernetes is deployed onto a cluster of computers, look at the following figure.</p>
</div>
<div class="browsable-container figure-container" data-hash="da93ca3b90470cd600d9b01c44bd892f" data-text-hash="835ca4262b2f21fa447f03da043682be" id="85" refid="85">
<h5>Figure 1.9 Computers in a Kubernetes cluster are divided into the Control Plane and the Workload Plane</h5>
<img alt="" data-processed="true" height="348" id="Picture_25" loading="lazy" src="EPUB/images/1.9.png" width="962">
</div>
<div class="readable-text" data-hash="d75475b5d37c852e2837781498e88fcb" data-text-hash="f83d6671f3d11da24e46c312b9f003c8" id="86" refid="86">
<p>You start with a fleet of machines that you divide into two groups - the master and the worker nodes. The master nodes will run the Kubernetes Control Plane, which represents the brain of your system and controls the cluster, while the rest will run your applications - your workloads - and will therefore represent the Workload Plane.</p>
</div>
<div class="callout-container fm-callout">
<div class="readable-text" data-hash="f35a087d0dc71beb3a7204d91c1c49e4" data-text-hash="3b0649c72650c313a357338dcdfb64ec" id="87" refid="87">
<h5>Note</h5>
</div>
<div class="readable-text" data-hash="5bb1a18189f35bb1862ad6d09df51ff0" data-text-hash="1ea62829f29d8f077d23e5aa8a9bbc6e" id="88" refid="88">
<p> The Workload Plane is sometimes referred to as the Data Plane, but this term could be confusing because the plane doesn&#8217;t host data but applications. Don&#8217;t be confused by the term &#8220;plane&#8221; either - in this context you can think of it as the &#8220;surface&#8221; the applications run on.</p>
</div>
</div>
<div class="readable-text" data-hash="b46b52bb24ea17718c5c4ac1cee11736" data-text-hash="a0e9f088d4b0313cad431b18818e2497" id="89" refid="89">
<p>Non-production clusters can use a single master node, but highly available clusters use at least three physical master nodes to host the Control Plane. The number of worker nodes depends on the number of applications you&#8217;ll deploy.</p>
</div>
<div class="readable-text" data-hash="2d68394d7af8826e94f2e953a7a7e9d3" data-text-hash="cd6e7009d9fb9e69f6978ef86bbdbb4b" id="90" refid="90">
<h4>How all cluster nodes become one large deployment area</h4>
</div>
<div class="readable-text" data-hash="ccec3b685d3c3cccc25ab242937bba3f" data-text-hash="bc8cac0f12820e583a432e03a4f98051" id="91" refid="91">
<p>After Kubernetes is installed on the computers, you no longer need to think about individual computers when deploying applications. Regardless of the number of worker nodes in your cluster, they all become a single space where you deploy your applications. You do this using the Kubernetes API, which is provided by the Kubernetes Control Plane.</p>
</div>
<div class="browsable-container figure-container" data-hash="c32e6571cda3038d5c69390facf951ff" data-text-hash="baa668d513ee0ff584c8344ab751f38a" id="92" refid="92">
<h5>Figure 1.10 Kubernetes exposes the cluster as a uniform deployment area</h5>
<img alt="" data-processed="true" height="280" id="Picture_26" loading="lazy" src="EPUB/images/1.10.png" width="948">
</div>
<div class="readable-text" data-hash="e08eae54e4f509906db1a1157a78455e" data-text-hash="a5dfcbfca6f8c5460aa3e19714ae4ab2" id="93" refid="93">
<p>When I say that all worker nodes become one space, I don&#8217;t want you to think that you can deploy an extremely large application that is spread across several small machines. Kubernetes doesn&#8217;t do magic tricks like this. Each application must be small enough to fit on one of the worker nodes.</p>
</div>
<div class="readable-text" data-hash="0c05d71191f350d2777fc3c96f94f281" data-text-hash="df11c7b55e4db19c98cd906b9dadc395" id="94" refid="94">
<p>What I meant was that when deploying applications, it doesn&#8217;t matter which worker node they end up on. Kubernetes may later even move the application from one node to another. You may not even notice when that happens, and you shouldn&#8217;t care.</p>
</div>
<div class="readable-text" data-hash="e7d2876d3fcafced4a559cc71cf93366" data-text-hash="5208600dcf60d9cec4fe6a0553b64458" id="95" refid="95">
<h3 id="sigil_toc_id_8">1.2.2&#160;&#160; The benefits of using Kubernetes</h3>
</div>
<div class="readable-text" data-hash="cb91d141a94e3b8a2194458e09306d8d" data-text-hash="1d6cff0bf6a171c377e5c68c80a17dce" id="96" refid="96">
<p>You&#8217;ve already learned why many organizations across the world have welcomed Kubernetes into their data centers. Now, let&#8217;s take a closer look at the specific benefits it brings to both development and IT operations teams.</p>
</div>
<div class="readable-text" data-hash="06ad1ef2df7442c10a128eda7a756a70" data-text-hash="231fb5576b5ce76daba183a05a2102ff" id="97" refid="97">
<h4>Self-service deployment of applications</h4>
</div>
<div class="readable-text" data-hash="f4b82dd4f044ac30be054eba180adf84" data-text-hash="4c203419ee70e865c45a4e64cecc122b" id="98" refid="98">
<p>Because Kubernetes presents all its worker nodes as a single deployment surface, it no longer matters which node you deploy your application to. This means that developers can now deploy applications on their own, even if they don&#8217;t know anything about the number of nodes or the characteristics of each node.</p>
</div>
<div class="readable-text" data-hash="e76e5485b783e8b01eb63967711f9297" data-text-hash="594f9c479761bd09b156d8195c0db431" id="99" refid="99">
<p>In the past, the system administrators were the ones who decided where each application should be placed. This task is now left to Kubernetes. This allows a developer to deploy applications without having to rely on other people to do so. When a developer deploys an application, Kubernetes chooses the best node on which to run the application based on the resource requirements of the application and the resources available on each node.</p>
</div>
<div class="readable-text" data-hash="574fad66b0ace8e10a7ad77ed36e367e" data-text-hash="8e858658f345aa97b92c3bde37f43e14" id="100" refid="100">
<h4>Reducing costs via better infrastructure utilization</h4>
</div>
<div class="readable-text" data-hash="61fa753eb8d7e36af12f792fed9c111f" data-text-hash="56a80428e006c5cfeba3807f97f3501c" id="101" refid="101">
<p>If you don&#8217;t care which node your application lands on, it also means that it can be moved to any other node at any time without you having to worry about it. Kubernetes may need to do this to make room for a larger application that someone wants to deploy. This ability to move applications allows the applications to be packed tightly together so that the resources of the nodes can be utilized in the best possible way.</p>
</div>
<div class="callout-container fm-callout">
<div class="readable-text" data-hash="f35a087d0dc71beb3a7204d91c1c49e4" data-text-hash="3b0649c72650c313a357338dcdfb64ec" id="102" refid="102">
<h5>Note</h5>
</div>
<div class="readable-text" data-hash="729a52635c957a333a78b6438fc5e291" data-text-hash="597c92a5fc1f2ed34efda8e6ca470b19" id="103" refid="103">
<p> In chapter 17 you&#8217;ll learn more about how Kubernetes decides where to place each application and how you can influence the decision.</p>
</div>
</div>
<div class="readable-text" data-hash="dd66292d06b2df059a5e2cf4e10b57bd" data-text-hash="2d76fe782258e9f6cd4ec0271dfe6390" id="104" refid="104">
<p>Finding optimal combinations can be challenging and time consuming, especially when the number of all possible options is huge, such as when you have many application components and many server nodes on which they can be deployed. Computers can perform this task much better and faster than humans. Kubernetes does it very well. By combining different applications on the same machines, Kubernetes improves the utilization of your hardware infrastructure so you can run more applications on fewer servers.</p>
</div>
<div class="readable-text" data-hash="b150a293ac77e7d84ef15776f24017dd" data-text-hash="2afd65646d5f3b14315241091bf52f5b" id="105" refid="105">
<h4>Automatically adjusting to changing load</h4>
</div>
<div class="readable-text" data-hash="112514e0f5f800019723724f846c782c" data-text-hash="b71cf5dbf6615584365903c030bf6fc5" id="106" refid="106">
<p>Using Kubernetes to manage your deployed applications also means that the operations team doesn&#8217;t have to constantly monitor the load of each application to respond to sudden load peaks. Kubernetes takes care of this also. It can monitor the resources consumed by each application and other metrics and adjust the number of running instances of each application to cope with increased load or resource usage.</p>
</div>
<div class="readable-text" data-hash="b13e3ae9be336bf80eb0973524d158ad" data-text-hash="574e2e751adaea183db1860979d1d800" id="107" refid="107">
<p>When you run Kubernetes on cloud infrastructure, it can even increase the size of your cluster by provisioning additional nodes through the cloud provider&#8217;s API. This way, you never run out of space to run additional instances of your applications.</p>
</div>
<div class="readable-text" data-hash="ae67d5f1a597c991f3edbc8318e1b42c" data-text-hash="882b4f2966dbe30123d5202004b91150" id="108" refid="108">
<h4>Keeping applications running smoothly</h4>
</div>
<div class="readable-text" data-hash="8aa2f40e6720f2798e00c6338397031c" data-text-hash="83a3495434ef4e2e9e4a2df0a27176d6" id="109" refid="109">
<p>Kubernetes also makes every effort to ensure that your applications run smoothly. If your application crashes, Kubernetes will restart it automatically. So even if you have a broken application that runs out of memory after running for more than a few hours, Kubernetes will ensure that your application continues to provide the service to its users by automatically restarting it in this case.</p>
</div>
<div class="readable-text" data-hash="3eb052ef247fa17d069a0b2efa4e18a5" data-text-hash="1256be5621aaa76829cba26b35100a84" id="110" refid="110">
<p>Kubernetes is a self-healing system in that it deals with software errors like the one just described, but it also handles hardware failures. As clusters grow in size, the frequency of node failure also increases. For example, in a cluster with one hundred nodes and a MTBF (mean-time-between-failure) of 100 days for each node, you can expect one node to fail every day.</p>
</div>
<div class="readable-text" data-hash="48bb3fae1258c7967834be6c3796ee19" data-text-hash="76876efad26cdee9c6a4f10c5b8cea41" id="111" refid="111">
<p>When a node fails, Kubernetes automatically moves applications to the remaining healthy nodes. The operations team no longer needs to manually move the application and can instead focus on repairing the node itself and returning it to the pool of available hardware resources.</p>
</div>
<div class="readable-text" data-hash="d7ecdc77da25ad8220fe7a452fd1f41b" data-text-hash="43559c4ffa65e84e8f77c6d05a1a1a71" id="112" refid="112">
<p>If your infrastructure has enough free resources to allow normal system operation without the failed node, the operations team doesn&#8217;t even have to react immediately to the failure. If it occurs in the middle of the night, no one from the operations team even has to wake up. They can sleep peacefully and deal with the failed node during regular working hours.</p>
</div>
<div class="readable-text" data-hash="2ba6eb6e2b8dcf14a72addc54d230907" data-text-hash="203f14706de4f73ae96069025f4d351c" id="113" refid="113">
<h4>Simplifying application development</h4>
</div>
<div class="readable-text" data-hash="c241d91e2ed19f7468af7142efaedce1" data-text-hash="9cd1fb7596685f93182f60888a4ccfb0" id="114" refid="114">
<p>The improvements described in the previous section mainly concern application deployment. But what about the process of application development? Does Kubernetes bring anything to their table? It definitely does.</p>
</div>
<div class="readable-text" data-hash="e70ad9cb1f050c7cf62eeb820ebeb66e" data-text-hash="0191cd6abc7bd07f1464c0cc1a16ae6b" id="115" refid="115">
<p>As mentioned previously, Kubernetes offers infrastructure-related services that would otherwise have to be implemented in your applications. This includes the discovery of services and/or peers in a distributed application, leader election, centralized application configuration and others. Kubernetes provides this while keeping the application Kubernetes-agnostic, but when required, applications can also query the Kubernetes API to obtain detailed information about their environment. They can also use the API to change the environment.</p>
</div>
<div class="readable-text" data-hash="a2f9eef8a57d492a4783a6295def36b2" data-text-hash="eb6c7ed1aa0c620cab6e30da9606c331" id="116" refid="116">
<h3 id="sigil_toc_id_9">1.2.3&#160;&#160; The architecture of a Kubernetes cluster</h3>
</div>
<div class="readable-text" data-hash="073aa13aa486d215099c1e7faca4de28" data-text-hash="6699fc774bd6fca4449fddd8a676b5a7" id="117" refid="117">
<p>As you&#8217;ve already learned, a Kubernetes cluster consists of nodes divided into two groups:</p>
</div>
<ul>
<li class="readable-text" data-hash="3ad3a3a79481b9d6b7fa1b6366a6b406" data-text-hash="d63493d6c3227062af2d0df326322539" id="118" refid="118">A set of <i>master nodes</i> that host the <i>Control Plane</i> components, which are the brains of the system, since they control the entire cluster.</li>
<li class="readable-text" data-hash="7c65321500bfe62585bc15715b33668e" data-text-hash="de306917402ae4afb28917525d224d06" id="119" refid="119">A set of <i>worker</i> <i>nodes</i> that form the <i>Workload Plane</i>, which is where your workloads (or applications) run.</li>
</ul>
<div class="readable-text" data-hash="1413ffd6be33740745bab02c3fe1c5b4" data-text-hash="6a8cacbfc00facc2f0641e6bbac61d55" id="120" refid="120">
<p>The following figure shows the two planes and the different nodes they consist of.</p>
</div>
<div class="browsable-container figure-container" data-hash="9e4be5725baec713a1a5c41850cf655d" data-text-hash="4cda516fdf6c576876a193fe52140fde" id="121" refid="121">
<h5>Figure 1.11 The two planes that make up a Kubernetes cluster</h5>
<img alt="" data-processed="true" height="446" id="Picture_27" loading="lazy" src="EPUB/images/1.11.png" width="960">
</div>
<div class="readable-text" data-hash="345146122fdd87f6280932b22b3c642a" data-text-hash="9c7269c62fcf7a193c20c7608c1177bc" id="122" refid="122">
<p>The two planes, and hence the two types of nodes, run different Kubernetes components. The next two sections of the book introduce them and summarize their functions without going into details. These components will be mentioned several times in the next part of the book where I explain the fundamental concepts of Kubernetes. An in-depth look at the components and their internals follows in the third part of the book.</p>
</div>
<div class="readable-text" data-hash="1fa3770026832ff47d7671a1cb02398c" data-text-hash="609908a86c61b139dd9ff82742e1b390" id="123" refid="123">
<h4>Control Plane components</h4>
</div>
<div class="readable-text" data-hash="6edc8144a694241be7079c8f2c9a8bab" data-text-hash="d4406fa0bc6b143c42540bb8e5c4d825" id="124" refid="124">
<p>The Control Plane is what controls the cluster. It consists of several components that run on a single master node or are replicated across multiple master nodes to ensure high availability. The Control Plane&#8217;s components are shown in the following figure.</p>
</div>
<div class="browsable-container figure-container" data-hash="e7b0be8f92e6034dd6ec6d0236fa19c8" data-text-hash="9da08f6a307acee3921825721ef7342f" id="125" refid="125">
<h5>Figure 1.12 The components of the Kubernetes Control Plane</h5>
<img alt="" data-processed="true" height="438" id="Picture_28" loading="lazy" src="EPUB/images/1.12.png" width="941">
</div>
<div class="readable-text" data-hash="d1e82b7fe2618ae7bf080171b8662d3b" data-text-hash="e5c6d29c4406e910298fa5c8b0b7d3d8" id="126" refid="126">
<p>These are the components and their functions:</p>
</div>
<ul>
<li class="readable-text" data-hash="6d919e6aa276dd2a14b407ac9cee3bea" data-text-hash="d8705b3b0716669790404d026b325b73" id="127" refid="127">The <i>Kubernetes</i> <i>API Server</i> exposes the RESTful Kubernetes API. Engineers using the cluster and other Kubernetes components create objects via this API.</li>
<li class="readable-text" data-hash="3f19cef1dbc023da4b8a20be6b53de0b" data-text-hash="2f3bb0ae3cd1dad8e7a1ca8789970e55" id="128" refid="128">The <i>etcd</i> distributed datastore persists the objects you create through the API, since the API Server itself is stateless. The Server is the only component that talks to etcd.</li>
<li class="readable-text" data-hash="df1e359969e5fdc9567c7cd49df725e4" data-text-hash="6a5800d5543c4e70aad9836c007ac8ef" id="129" refid="129">The <i>Scheduler</i> decides on which worker node each application instance should run.</li>
<li class="readable-text" data-hash="0678a631f537deaf45e0488d07792e12" data-text-hash="02c30c0be669320fcb05eeca658e4b8b" id="130" refid="130"><i>Controllers</i> bring to life the objects you create through the API. Most of them simply create other objects, but some also communicate with external systems (for example, the cloud provider via its API).</li>
</ul>
<div class="readable-text" data-hash="4f354e4b1aaac52219e30e6d33ccd81e" data-text-hash="3d5337ccb0f7deaf021462d388d68c72" id="131" refid="131">
<p>The components of the Control Plane hold and control the state of the cluster, but they don&#8217;t run y<a href="v-15.html" id="RTF5f476f4261636b">our applications. This is done by the (worker</a>) nodes.</p>
</div>
<div class="readable-text" data-hash="fe434b9c9ab5369db657e2c0ad3ee72d" data-text-hash="9c994210007ccba40db0eb63c2dc38df" id="132" refid="132">
<h4>Worker node components</h4>
</div>
<div class="readable-text" data-hash="3ea237b383dfb25826ba9b0667be7793" data-text-hash="472670d9f0ebfd414b341110f78d2d41" id="133" refid="133">
<p>The worker nodes are the computers on which your applications run. They form the cluster&#8217;s Workload Plane. In addition to applications, several Kubernetes components also run on these nodes. They perform the task of running, monitoring and providing connectivity between your applications. They are shown in the following figure.</p>
</div>
<div class="browsable-container figure-container" data-hash="82530ce1c9aa586ad9bf64454c4ccd18" data-text-hash="574f71549373baf2ee4f469c006f0aa3" id="134" refid="134">
<h5>Figure 1.13 The Kubernetes components that run on each node</h5>
<img alt="" data-processed="true" height="353" loading="lazy" src="EPUB/images/1.13.png" width="731">
</div>
<div class="readable-text" data-hash="2f14aacd7a90d36d14cd3bccf016f3ab" data-text-hash="2ab57e3ecadff1ff5746e9a2e391abf9" id="135" refid="135">
<p>Each node runs the following set of components:</p>
</div>
<ul>
<li class="readable-text" data-hash="0432e902f822372fbd06b792a9fed22b" data-text-hash="2dd7546ff94bfef90cf2889de3717673" id="136" refid="136">The <i>Kubelet</i>, an agent that talks to the API server and manages the applications running on its node. It reports the status of these applications and the node via the API.</li>
<li class="readable-text" data-hash="cc91cef66943036b30346f2805b3e0a0" data-text-hash="dbccb4a2ad8cfb180cf3848ac119faf0" id="137" refid="137">The <i>Container Runtime</i>, which can be Docker or any other runtime compatible with Kubernetes. It runs your applications in containers as instructed by the Kubelet.</li>
<li class="readable-text" data-hash="7b35ad11ea9f36cbe25a2855a3ab217a" data-text-hash="8c61d0b7ef467315c7eaa2634e58e5ad" id="138" refid="138">The <i>Kubernetes Service Proxy (Kube Proxy)</i> load-balances network traffic between applications. Its name suggests that traffic flows through it, but that&#8217;s no longer the case. You&#8217;ll learn why in chapter 14.</li>
</ul>
<div class="readable-text" data-hash="358b0851debed593a69c167b11ad4395" data-text-hash="49197fe872103a3102b055d49ee8a432" id="139" refid="139">
<h4>Add-on components</h4>
</div>
<div class="readable-text" data-hash="b28a738960070676bad94f08a27cb9f8" data-text-hash="9068be851747b6a5b825fe47f0d95c1a" id="140" refid="140">
<p>Most Kubernetes clusters also contain several other components. This includes a DNS server, network plugins, logging agents and many others. They typically run on the worker nodes but can also be configured to run on the master.</p>
</div>
<div class="readable-text" data-hash="8a98b8d52c4fdb0e7ee73141dc9df716" data-text-hash="be36f0ffb526513fb009562bec0fb1a4" id="141" refid="141">
<h4>Gaining a deeper understanding of the architecture</h4>
</div>
<div class="readable-text" data-hash="b51d0fc3339785e944cb28ac2b156aea" data-text-hash="11b873c6969f2573254eece104054166" id="142" refid="142">
<p>For now, I only expect you to be vaguely familiar with the names of these components and their function, as I&#8217;ll mention them many times throughout the following chapters. You&#8217;ll learn snippets about them in these chapters, but I&#8217;ll explain them in more detail in chapter 14.</p>
</div>
<div class="readable-text" data-hash="5cba61e448f3f124648c9cf70af5a387" data-text-hash="213ef2e974e90a619f953abbb49ce0da" id="143" refid="143">
<p>I&#8217;m not a fan of explaining how things work until I first explain <i>what</i> something does and teach you how to use it. It&#8217;s like learning to drive. You don&#8217;t want to know what&#8217;s under the hood. At first, you just want to learn how to get from point A to B. Only then will you be interested in how the car makes this possible. Knowing what&#8217;s under the hood may one day help you get your car moving again after it has broken down and you are stranded on the side of the road. I hate to say it, but you&#8217;ll have many moments like this when dealing with Kubernetes due to its sheer complexity.</p>
</div>
<div class="readable-text" data-hash="03866c3cb2304ecce40f47d366e797a2" data-text-hash="aea0d3ef94eccbcaa72f498e428c0dff" id="144" refid="144">
<h3 id="sigil_toc_id_10">1.2.4&#160;&#160; How Kubernetes runs an application</h3>
</div>
<div class="readable-text" data-hash="dbeb5d270d37b223ac3995f9e741a76d" data-text-hash="3de2e4e02a34489ad408b01e5a21e6fc" id="145" refid="145">
<p>With a general overview of the components that make up Kubernetes, I can finally explain how to deploy an application in Kubernetes.</p>
</div>
<div class="readable-text" data-hash="41b98ca8b88eb4ad6a42ba045bf78032" data-text-hash="5001c67cd87aee3d0a5200067754fd90" id="146" refid="146">
<h4>Defining your application</h4>
</div>
<div class="readable-text" data-hash="05aae8523626148b3876db2edb67e04f" data-text-hash="bd2fd013238edd76b6c501bb05816414" id="147" refid="147">
<p>Everything in Kubernetes is represented by an object. You create and retrieve these objects via the Kubernetes API. Your application consists of several types of these objects - one type represents the application deployment as a whole, another represents a running instance of your application, another represents the service provided by a set of these instances and allows reaching them at a single IP address, and there are many others.</p>
</div>
<div class="readable-text" data-hash="d5e30879fbcdc93a5054569aadda7b04" data-text-hash="356c242aeacb6cfc474c9984dd05751f" id="148" refid="148">
<p>All these types are explained in detail in the second part of the book. At the moment, it&#8217;s enough to know that you define your application through several types of objects. These objects are usually defined in one or more manifest files in either YAML or JSON format.</p>
</div>
<div class="callout-container fm-callout">
<div class="readable-text" data-hash="079b754eeb5041e4c4cbe9936322a95c" data-text-hash="0b890b1926b90387673882e6ccae7fdc" id="149" refid="149">
<h5>Definition</h5>
</div>
<div class="readable-text" data-hash="542560ebd84b2570abd20ae1355b7d7a" data-text-hash="5af11ae5bc0690272fd33227456240ce" id="150" refid="150">
<p> YAML was initially said to mean &#8220;Yet Another Markup Language&#8221;, but it was latter changed to the recursive acronym &#8220;YAML Ain&#8217;t Markup Language&#8221;. It&#8217;s one of the ways to serialize an object into a human-readable text file.</p>
</div>
</div>
<div class="callout-container fm-callout">
<div class="readable-text" data-hash="079b754eeb5041e4c4cbe9936322a95c" data-text-hash="0b890b1926b90387673882e6ccae7fdc" id="151" refid="151">
<h5>Definition</h5>
</div>
<div class="readable-text" data-hash="55979fc4537e3479446c975412dbd7d2" data-text-hash="5c7eb33d0f93daa9d9e42b55990fb2f8" id="152" refid="152">
<p> JSON is short for JavaScript Object Notation. It&#8217;s a different way of serializing an object, but more suitable for exchanging data between applications.</p>
</div>
</div>
<div class="readable-text" data-hash="dd46834d86c54ec4545beadb98b08a65" data-text-hash="48f5b6c13af75f22c6cb59f35cc15208" id="153" refid="153">
<p>The following figure shows an example of deploying an application by creating a manifest with two deployments exposed using two services.</p>
</div>
<div class="browsable-container figure-container" data-hash="6adc9eca396301cecc75e458ca4f973a" data-text-hash="8e11a4e536a3b32c5c6464a2c18b4556" id="154" refid="154">
<h5>Figure 1.14 Deploying an application to Kubernetes</h5>
<img alt="" data-processed="true" height="540" id="Picture_13" loading="lazy" src="EPUB/images/1.14.png" width="960">
</div>
<div class="readable-text" data-hash="cde152a3cf4996846f22aec3fd52bd28" data-text-hash="321456cfc286a8961232d29e2453206f" id="155" refid="155">
<p>These actions take place when you deploy the application:</p>
</div>
<ol>
<li class="readable-text" data-hash="394fe978cda7e9951abe02dc822e72a8" data-text-hash="394fe978cda7e9951abe02dc822e72a8" id="156" refid="156">You submit the application manifest to the Kubernetes API. The API Server writes the objects defined in the manifest to etcd.</li>
<li class="readable-text" data-hash="71eaae189762c40e276230984fdec37b" data-text-hash="71eaae189762c40e276230984fdec37b" id="157" refid="157">A controller notices the newly created objects and creates several new objects - one for each application instance.</li>
<li class="readable-text" data-hash="61b61e26beb2376ec4a28c9d5f87b0c1" data-text-hash="61b61e26beb2376ec4a28c9d5f87b0c1" id="158" refid="158">The Scheduler assigns a node to each instance.</li>
<li class="readable-text" data-hash="518f01e553fb55c578c687fab024304e" data-text-hash="518f01e553fb55c578c687fab024304e" id="159" refid="159">The Kubelet notices that an instance is assigned to the Kubelet&#8217;s node. It runs the application instance via the Container Runtime.</li>
<li class="readable-text" data-hash="29044c5a496f5ba451d0fdb8d000a638" data-text-hash="29044c5a496f5ba451d0fdb8d000a638" id="160" refid="160">The Kube Proxy notices that the application instances are ready to accept connections from clients and configures a load balancer for them.</li>
<li class="readable-text" data-hash="e44e287c79f6edbb4882c3b269639133" data-text-hash="e44e287c79f6edbb4882c3b269639133" id="161" refid="161">The Kubelets and the Controllers monitor the system and keep the applications running.</li>
</ol>
<div class="readable-text" data-hash="410df4793c563ce215ca73beda45d3ee" data-text-hash="a1753f72c191b3497861ada1e8ffe1b1" id="162" refid="162">
<p>The procedure is explained in more detail in the following sections, but the complete explanation is given in chapter 14, after you have familiarized yourself with all the objects and controllers involved.</p>
</div>
<div class="readable-text" data-hash="354922414b41e42c0914a3d0fd5a0b41" data-text-hash="5543546473a4628f183426a6fe8acfe5" id="163" refid="163">
<h4>Submitting the application to the API</h4>
</div>
<div class="readable-text" data-hash="8aa41e20012e69766e1ad8d7afda140b" data-text-hash="8eadd368ba3f35a66bc79ecbe6619924" id="164" refid="164">
<p>After you&#8217;ve created your YAML or JSON file(s), you submit the file to the API, usually via the Kubernetes command-line tool called <i>kubectl</i>.</p>
</div>
<div class="callout-container fm-callout">
<div class="readable-text" data-hash="f35a087d0dc71beb3a7204d91c1c49e4" data-text-hash="3b0649c72650c313a357338dcdfb64ec" id="165" refid="165">
<h5>Note</h5>
</div>
<div class="readable-text" data-hash="c7a081e084f9c042b643dd390cf2a296" data-text-hash="c578274ccfb17744ce2b47b2dc514c5a" id="166" refid="166">
<p> Kubectl is pronounced <i>kube-control</i>, but the softer souls in the community prefer to call it <i>kube-cuddle</i>. Some refer to it as <i>kube-C-T-L</i>.</p>
</div>
</div>
<div class="readable-text" data-hash="59fb34f23c178e51de3b30cbd4beb06f" data-text-hash="7ab3df27528c7037decb76b0207ff787" id="167" refid="167">
<p>Kubectl splits the file into individual objects and creates each of them by sending an HTTP PUT or POST request to the API, as is usually the case with RESTful APIs. The API Server validates the objects and stores them in the etcd datastore. In addition, it notifies all interested components that these objects have been created. Controllers, which are explained next, are one of these components.</p>
</div>
<div class="readable-text" data-hash="2067e4b8e42f2426e426baa6c57bc5b7" data-text-hash="a7e14a34d2eecc20f3186614c0e1ec45" id="168" refid="168">
<h4>About the controllers</h4>
</div>
<div class="readable-text" data-hash="f10f42a455d231de7c328f1b751654ef" data-text-hash="81e9faf1c5600d8e056317acb2ab3b99" id="169" refid="169">
<p>Most object types have an associated controller. A controller is interested in a particular object type. It waits for the API server to notify it that a new object has been created, and then performs operations to bring that object to life. Typically, the controller just creates other objects via the same Kubernetes API. For example, the controller responsible for application deployments creates one or more objects that represent individual instances of the application. The number of objects created by the controller depends on the number of replicas specified in the application deployment object.</p>
</div>
<div class="readable-text" data-hash="f6d624aa4413d1f28d05122a9b546de7" data-text-hash="91b6dc9c86119f8ebd23b433fe6abf29" id="170" refid="170">
<h4>About the Scheduler</h4>
</div>
<div class="readable-text" data-hash="046bf831f0e102eb6a0c3c9c5d4bad7a" data-text-hash="0ab1c74822845b0e8d4fc862d648abba" id="171" refid="171">
<p>The scheduler is a special type of controller, whose only task is to schedule application instances onto worker nodes. It selects the best worker node for each new application instance object and assigns it to the instance - by modifying the object via the API.</p>
</div>
<div class="readable-text" data-hash="c8ba810d3a8b462268e49cd41857bb1a" data-text-hash="9c0912beb78308b2605478f942bdc468" id="172" refid="172">
<h4>About the Kubelet and the Container Runtime</h4>
</div>
<div class="readable-text" data-hash="c6df58c2f21b23b64c8c5087d2d69a5c" data-text-hash="8e903e86e0b61ff636c483fcf3172612" id="173" refid="173">
<p>The Kubelet that runs on each worker node is also a type of controller. Its task is to wait for application instances to be assigned to the node on which it is located and run the application. This is done by instructing the Container Runtime to start the application&#8217;s container.</p>
</div>
<div class="readable-text" data-hash="ba1453801b248b0aacb9c3de3527e627" data-text-hash="9f71b950d767153ac1aa4a64733cba38" id="174" refid="174">
<h4>About the Kube Proxy</h4>
</div>
<div class="readable-text" data-hash="b382acd38bf2f53b4823d31d29bceea4" data-text-hash="db40e25fdd131947ffa9f402621fe440" id="175" refid="175">
<p>Because an application deployment can consist of multiple application instances, a load balancer is required to expose them at a single IP address. The Kube Proxy, another controller running alongside the Kubelet, is responsible for setting up the load balancer.</p>
</div>
<div class="readable-text" data-hash="ebdeb8c78a99cef69758c78016fc9b26" data-text-hash="106e9925d711712433eee615a23af049" id="176" refid="176">
<h4>Keeping the applications healthy</h4>
</div>
<div class="readable-text" data-hash="71e88a150280a58d26204ef0ee0af8f8" data-text-hash="21d17995c6ef69fb1a0b42bf3786b6d6" id="177" refid="177">
<p>Once the application is up and running, the Kubelet keeps the application healthy by restarting it when it terminates. It also reports the status of the application by updating the object that represents the application instance. The other controllers monitor these objects and ensure that applications are moved to healthy nodes if their nodes fail.</p>
</div>
<div class="readable-text" data-hash="30a957bf53e7b124acf5e74585d64722" data-text-hash="d60fd81299ebfdbac2668af98452a7f6" id="178" refid="178">
<p>You&#8217;re now roughly familiar with the architecture and functionality of Kubernetes. You don&#8217;t need to understand or remember all the details at this moment, because internalizing this information will be easier when you learn about each individual object types and the controllers that bring them to life in the second part of the book.</p>
</div>
<div class="readable-text" data-hash="486687a164bc1b07e1c7d5c6dc75285f" data-text-hash="1d8e6625c083a4784350c16043b26ca3" id="179" refid="179">
<h2 id="sigil_toc_id_11">1.3&#160;Introducing Kubernetes into your organization</h2>
</div>
<div class="readable-text" data-hash="631e242dcbb5ab958d674a6b3f27b042" data-text-hash="1ad23fab35dc0a858d9812e6fe8bebc2" id="180" refid="180">
<p>To close this chapter, let&#8217;s see what options are available to you if you decide to introduce Kubernetes in your own IT environment.</p>
</div>
<div class="readable-text" data-hash="3129a0299f5b05714a4d3237ba34412f" data-text-hash="1634d60f08c110dd7b9389ebe876fc1c" id="181" refid="181">
<h3 id="sigil_toc_id_12">1.3.1&#160;&#160; Running Kubernetes on-premises and in the cloud</h3>
</div>
<div class="readable-text" data-hash="731b7dbc3f15983e2b17531475515494" data-text-hash="219f49502022f9189de56237ba59bb9d" id="182" refid="182">
<p>If you want to run your applications on Kubernetes, you have to decide whether you want to run them locally, in your organization&#8217;s own infrastructure (on-premises) or with one of the major cloud providers, or perhaps both - in a hybrid cloud solution.</p>
</div>
<div class="readable-text" data-hash="b5cc284d6d3556414e16e043890900c0" data-text-hash="0c89de5c80a3b156d1f81f3f4f0277bb" id="183" refid="183">
<h4>Running Kubernetes on-premises</h4>
</div>
<div class="readable-text" data-hash="ee91204a23a7a2af31ae9919af5ff423" data-text-hash="2e5838d828b83a0a98ca3863dff62263" id="184" refid="184">
<p>Running Kubernetes on your own infrastructure may be your only option if regulations require you to run applications on site. This usually means that you&#8217;ll have to manage Kubernetes yourself, but we&#8217;ll come to that later.</p>
</div>
<div class="readable-text" data-hash="c3bd22bbf246b62df972c4e09a38f6e0" data-text-hash="07f9e4c2944042260911bb4cf4a921f4" id="185" refid="185">
<p>Kubernetes can run directly on your bare-metal machines or in virtual machines running in your data center. In either case, you won&#8217;t be able to scale your cluster as easily as when you run it in virtual machines provided by a cloud provider.</p>
</div>
<div class="readable-text" data-hash="f30b1625ec7aa171f129f35337a618ef" data-text-hash="f4d8b882f9d2254f71d2da5bf508a9d0" id="186" refid="186">
<h4>Deploying Kubernetes in the cloud</h4>
</div>
<div class="readable-text" data-hash="33c9e28445ee80ff0ed877d0c1b5f8cf" data-text-hash="f898f3fdae6bdba62ba4e625c9b63d89" id="187" refid="187">
<p>If you have no on-premises infrastructure, you have no choice but to run Kubernetes in the cloud. This has the advantage that you can scale your cluster at any time at short notice if required. As mentioned earlier, Kubernetes itself can ask the cloud provider to provision additional virtual machines when the current size of the cluster is no longer sufficient to run all the applications you want to deploy.</p>
</div>
<div class="readable-text" data-hash="6cb4ebf82d09a2c030639683ade2835d" data-text-hash="aba0ef102a27a4a5f296a93f33466f10" id="188" refid="188">
<p>When the number of workloads decreases and some worker nodes are left without running workloads, Kubernetes can ask the cloud provider to destroy the virtual machines of these nodes to reduce your operational costs. This elasticity of the cluster is certainly one of the main benefits of running Kubernetes in the cloud.</p>
</div>
<div class="readable-text" data-hash="cbfa89163d1c881764d467f0a28579eb" data-text-hash="e8d60bb452bdfe0903c890b5867ebd51" id="189" refid="189">
<h4>Using a hybrid cloud solution</h4>
</div>
<div class="readable-text" data-hash="18a9201d6fcc829633cc0e3fbcf383ea" data-text-hash="6acb3c4883996270c7994aca7f728a31" id="190" refid="190">
<p>A more complex option is to run Kubernetes on-premises, but also allow it to spill over into the cloud. It&#8217;s possible to configure Kubernetes to provision additional nodes in the cloud if you exceed the capacity of your own data center. This way, you get the best of both worlds. Most of the time, your applications run locally without the cost of virtual machine rental, but in short periods of peak load that may occur only a few times a year, your applications can handle the extra load by using the additional resources in the cloud.</p>
</div>
<div class="readable-text" data-hash="5b00e4bd95b5e8140333f346649138c8" data-text-hash="c3e6ba124c9bc23d085b72d2278e1527" id="191" refid="191">
<p>If your use-case requires it, you can also run a Kubernetes cluster across multiple cloud providers or a combination of any of the options mentioned. This can be done using a single control plane or one control plane in each location.</p>
</div>
<div class="readable-text" data-hash="2fadf3dae5cf23098ed25a87f21b99c1" data-text-hash="0b1419d90a99e8553b6e88fba2fe703a" id="192" refid="192">
<h3 id="sigil_toc_id_13">1.3.2&#160;&#160; To manage or not to manage Kubernetes yourself</h3>
</div>
<div class="readable-text" data-hash="84535986a10b4b71e4f844b7afbc2720" data-text-hash="3bed3b77fef99e8d4b0e14f1e5c3567e" id="193" refid="193">
<p>If you are considering introducing Kubernetes in your organization, the most important question you need to answer is whether you&#8217;ll manage Kubernetes yourself or use a Kubernetes-as-a-Service type offering where someone else manages it for you.</p>
</div>
<div class="readable-text" data-hash="abd1a165e3094101d93efe566977d23d" data-text-hash="2649512a927129260a3626a8c66b60c7" id="194" refid="194">
<h4>Managing Kubernetes yourself</h4>
</div>
<div class="readable-text" data-hash="f13a5095365cad588f616722bca41687" data-text-hash="2b24b5f25d6e40897b0f625e91cdf7f4" id="195" refid="195">
<p>If you already run applications on-premises and have enough hardware to run a production-ready Kubernetes cluster, your first instinct is probably to deploy and manage it yourself. If you ask anyone in the Kubernetes community if this is a good idea, you&#8217;ll usually get a very definite &#8220;no&#8221;.</p>
</div>
<div class="readable-text" data-hash="152d82b83ddab26c5b8e6d05ba37b492" data-text-hash="5ca79de846a27fd313250e2d3cfd4594" id="196" refid="196">
<p>Figure 1.14 was a very simplified representation of what happens in a Kubernetes cluster when you deploy an application. Even that figure should have scared you. Kubernetes brings with it an enormous amount of additional complexity. Anyone who wants to run a Kubernetes cluster must be intimately familiar with its inner workings.</p>
</div>
<div class="readable-text" data-hash="1303eabaee1b4253cc4f7a5abb18a22a" data-text-hash="705d239cc1a6f8cd5294922ff1875313" id="197" refid="197">
<p>The management of production-ready Kubernetes clusters is a multi-billion-dollar industry. Before you decide to manage one yourself, it&#8217;s essential that you consult with engineers who have already done it to learn about the issues most teams run into. If you don&#8217;t, you may be setting yourself up for failure. On the other hand, trying out Kubernetes for non-production use-cases or using a managed Kubernetes cluster is much less problematic.</p>
</div>
<div class="readable-text" data-hash="9204f5283199d0beebf38410445aa89b" data-text-hash="34be899866eeedd454f615f1af3b4b3b" id="198" refid="198">
<h4>Using a managed Kubernetes cluster in the cloud</h4>
</div>
<div class="readable-text" data-hash="c2a2757cbafb90ab997a4b5bddbe110e" data-text-hash="cee4942598a396584125380208eddbaf" id="199" refid="199">
<p>Using Kubernetes is ten times easier than managing it. Most major cloud providers now offer Kubernetes-as-a-Service. They take care of managing Kubernetes and its components while you simply use the Kubernetes API like any of the other APIs the cloud provider offers.</p>
</div>
<div class="readable-text" data-hash="210954742aaefb2db1fbacc41652ed07" data-text-hash="32e0d99c5a8e62c188a5241204c170b0" id="200" refid="200">
<p>The top managed Kubernetes offerings include the following:</p>
</div>
<ul>
<li class="readable-text" data-hash="974030a30a48754684d05541fd5e96c9" data-text-hash="974030a30a48754684d05541fd5e96c9" id="201" refid="201">Google Kubernetes Engine (GKE)</li>
<li class="readable-text" data-hash="f28c5620810ae2a6961a1811277a7ff8" data-text-hash="f28c5620810ae2a6961a1811277a7ff8" id="202" refid="202">Azure Kubernetes Service (AKS)</li>
<li class="readable-text" data-hash="480c9b5f979d1ce95ea2a58b09826d1b" data-text-hash="480c9b5f979d1ce95ea2a58b09826d1b" id="203" refid="203">Amazon Elastic Kubernetes Service (EKS)</li>
<li class="readable-text" data-hash="570528b5842770b27b3b832147a19813" data-text-hash="570528b5842770b27b3b832147a19813" id="204" refid="204">IBM Cloud Kubernetes Service</li>
<li class="readable-text" data-hash="d314cd8f54c57e254d97babb0fa49376" data-text-hash="d314cd8f54c57e254d97babb0fa49376" id="205" refid="205">Red Hat OpenShift Online and Dedicated</li>
<li class="readable-text" data-hash="3f1cbac53b9e316f5fc5283796d8ac5f" data-text-hash="3f1cbac53b9e316f5fc5283796d8ac5f" id="206" refid="206">VMware Cloud PKS</li>
<li class="readable-text" data-hash="9e4eba95348c69b66ff485e1df84579e" data-text-hash="9e4eba95348c69b66ff485e1df84579e" id="207" refid="207">Alibaba Cloud Container Service for Kubernetes (ACK)</li>
</ul>
<div class="readable-text" data-hash="26a2165c994a29b7f8f58f635afe56dc" data-text-hash="96eeaee68469da343afb1f2b6daf17f4" id="208" refid="208">
<p>The first half of this book focuses on just using Kubernetes. You&#8217;ll run the exercises in a local development cluster and on a managed GKE cluster, as I find it&#8217;s the easiest to use and offers the best user experience. The second part of the book gives you a solid foundation for managing Kubernetes, but to truly master it, you&#8217;ll need to gain additional experience.</p>
</div>
<div class="readable-text" data-hash="e0da57cef769f38c8aeae0b021d719a2" data-text-hash="6ddda415a211a564619702970c63a657" id="209" refid="209">
<h3 id="sigil_toc_id_14">1.3.3&#160;&#160; Using vanilla or extended Kubernetes</h3>
</div>
<div class="readable-text" data-hash="e970680dd0db821259e796b9394c1888" data-text-hash="a0cce144d35400c65e6d7d4d8a221e45" id="210" refid="210">
<p>The final question is whether to use a vanilla open-source version of Kubernetes or an extended, enterprise-quality Kubernetes product.</p>
</div>
<div class="readable-text" data-hash="2facbabe498a23c0ad7c7398ef151288" data-text-hash="6ed0bcaba9a7fa3a56554eb72b036799" id="211" refid="211">
<h4>Using a vanilla version of Kubernetes</h4>
</div>
<div class="readable-text" data-hash="2582f4324f5ca2e0ac64de5cce21699c" data-text-hash="47ca5f08e75da1490735e098b568028c" id="212" refid="212">
<p>The open-source version of Kubernetes is maintained by the community and represents the cutting edge of Kubernetes development. This also means that it may not be as stable as the other options. It may also lack good security defaults. Deploying the vanilla version requires a lot of fine tuning to set everything up for production use.</p>
</div>
<div class="readable-text" data-hash="5f40e95297888ca50ddb5907f012a12f" data-text-hash="82f4af4f9e793f2428e3b5c1a4e0dbcd" id="213" refid="213">
<h4>Using enterprise-grade Kubernetes distributions</h4>
</div>
<div class="readable-text" data-hash="2c8983941a91af9c81776a52becf7061" data-text-hash="f146bd6e7e839ddca21ea42b08cf9bee" id="214" refid="214">
<p>A better option for using Kubernetes in production is to use an enterprise-quality Kubernetes distribution such as OpenShift or Rancher. In addition to the increased security and performance provided by better defaults, they offer additional object types in addition to those provided in the upstream Kubernetes API. For example, vanilla Kubernetes does not contain object types that represent cluster users, whereas commercial distributions do. They also provide additional software tools for deploying and managing well-known third-party applications on Kubernetes.</p>
</div>
<div class="readable-text" data-hash="a5e4bd1545f4da56d34ac902e74a365f" data-text-hash="6f5df3275a9885dd6a83d6396f7ac5df" id="215" refid="215">
<p>Of course, extending and hardening Kubernetes takes time, so these commercial Kubernetes distributions usually lag one or two versions behind the upstream version of Kubernetes. It&#8217;s not as bad as it sounds. The benefits usually outweigh the disadvantages.</p>
</div>
<div class="readable-text" data-hash="b623109bac45540d6b53f9c8b618330d" data-text-hash="eb1024c0523036aa04e3c7f81269a308" id="216" refid="216">
<h3 id="sigil_toc_id_15">1.3.4&#160;&#160; Should you even use Kubernetes?</h3>
</div>
<div class="readable-text" data-hash="cd410e42c02e4c2d4802e7775ac2a5a9" data-text-hash="821f68445567d8463c75808cb5b99bc2" id="217" refid="217">
<p>I hope this chapter has made you excited about Kubernetes and you can&#8217;t wait to squeeze it into your IT stack. But to close this chapter properly, we need to say a word or two about when introducing Kubernetes is not a good idea.</p>
</div>
<div class="readable-text" data-hash="74a21cdaf9a3119c0c6d5610e5ee0b10" data-text-hash="840bec8555eca36662c8691f860ac9c8" id="218" refid="218">
<h4>Do your workloads require automated management?</h4>
</div>
<div class="readable-text" data-hash="3738a52971743485492052b92f584ecc" data-text-hash="e64613b5da368a1a75138697c1c57516" id="219" refid="219">
<p>The first thing you need to be honest about is whether you need to automate the management of your applications at all. If your application is a large monolith, you definitely don&#8217;t need Kubernetes.</p>
</div>
<div class="readable-text" data-hash="25dbfb66d60aab540b8b8ceccb6aad95" data-text-hash="eeca70b8eaf8d5e2c8771a43e3df8bbd" id="220" refid="220">
<p>Even if you deploy microservices, using Kubernetes may not be the best option, especially if the number of your microservices is very small. It&#8217;s difficult to provide an exact number when the scales tip over, since other factors also influence the decision. But if your system consists of less than five microservices, throwing Kubernetes into the mix is probably not a good idea. If your system has more than twenty microservices, you will most likely benefit from the integration of Kubernetes. If the number of your microservices falls somewhere in between, other factors, such as the ones described next, should be considered.</p>
</div>
<div class="readable-text" data-hash="2150245f4be72e36c8795fff4fa2cd7d" data-text-hash="67e123c45475623f995cd97523e157e0" id="221" refid="221">
<h4>Can you afford to invest your engineers&#8217; time into learning Kubernetes?</h4>
</div>
<div class="readable-text" data-hash="30468476aff2b90cf560a2b0c2e940a8" data-text-hash="e9a04c3ace67d0d8aef74626fea9e5dd" id="222" refid="222">
<p>Kubernetes is designed to allow applications to run without them knowing that they are running in Kubernetes. While the applications themselves don&#8217;t need to be modified to run in Kubernetes, development engineers will inevitably spend a lot of time learning how to use Kubernetes, even though the operators are the only ones that actually need that knowledge.</p>
</div>
<div class="readable-text" data-hash="d48e9548a302f562394835b1353933fc" data-text-hash="43d27b49a426593f22f5c2802bdc6b53" id="223" refid="223">
<p>It would be hard to tell your teams that you&#8217;re switching to Kubernetes and expect only the operations team to start exploring it. Developers like shiny new things. At the time of writing, Kubernetes is still a very shiny thing.</p>
</div>
<div class="readable-text" data-hash="d9479d011ba0864aca76d0c091500660" data-text-hash="25137f24ace81bf91d58f9962a684da2" id="224" refid="224">
<h4>Are you prepared for increased costs in the interim?</h4>
</div>
<div class="readable-text" data-hash="50e4b0fb10836a2d8616de99d8a125ca" data-text-hash="83f49f1191bc95eb81d41b7c658deb3e" id="225" refid="225">
<p>While Kubernetes reduces long-term operational costs, introducing Kubernetes in your organization initially involves increased costs for training, hiring new engineers, building and purchasing new tools and possibly additional hardware. Kubernetes requires additional computing resources in addition to the resources that the applications use.</p>
</div>
<div class="readable-text" data-hash="375e68d62968e74a50a7fc9159c98d26" data-text-hash="2281638927bb7d3c109dbdc506856571" id="226" refid="226">
<h4>Don&#8217;t believe the hype</h4>
</div>
<div class="readable-text" data-hash="a982ec1ebffd0cc8aaa9ef62de104e4b" data-text-hash="1d2d9c1c88ad5c593743af4e0228aa4b" id="227" refid="227">
<p>Although Kubernetes has been around for several years at the time of writing this book, I can&#8217;t say that the hype phase is over. The initial excitement has just begun to calm down, but many engineers may still be unable to make rational decisions about whether the integration of Kubernetes is as necessary as it seems.</p>
</div>
<div class="readable-text" data-hash="6bdd1e8a99061baa78030e6e55503a12" data-text-hash="5efc30a42372d92ecc4ad0d2f3d848de" id="228" refid="228">
<h2 id="sigil_toc_id_16">1.4&#160;Summary</h2>
</div>
<div class="readable-text" data-hash="c0b0e3ad75fe902eab1a81b8aac06679" data-text-hash="befd99ae71178d6b0b89e33e3c00b5d1" id="229" refid="229">
<p>In this introductory chapter, you&#8217;ve learned that:</p>
</div>
<ul>
<li class="readable-text" data-hash="2c0bbbc95cdae18f058ae0ca2099cc08" data-text-hash="2c0bbbc95cdae18f058ae0ca2099cc08" id="230" refid="230">Kubernetes is Greek for helmsman. As a ship&#8217;s captain oversees the ship while the helmsman steers it, you oversee your computer cluster, while Kubernetes performs the day-to-day management tasks.</li>
<li class="readable-text" data-hash="79fa69bb7a06a816132cf68dd3517a60" data-text-hash="d0c7e6afcbd853780975d55c1a27d4cb" id="231" refid="231">Kubernetes is pronounced <i>koo-ber-netties</i>. Kubectl, the Kubernetes command-line tool, is pronounced <i>kube-control</i>.</li>
<li class="readable-text" data-hash="f3ca7f53e72e1df87fb3503196c34627" data-text-hash="f3ca7f53e72e1df87fb3503196c34627" id="232" refid="232">Kubernetes is an open-source project built upon Google&#8217;s vast experience in running applications on a global scale. Thousands of individuals now contribute to it.</li>
<li class="readable-text" data-hash="e8c60c1680f868b4124500358d2184b4" data-text-hash="e8c60c1680f868b4124500358d2184b4" id="233" refid="233">Kubernetes uses a declarative model to describe application deployments. After you provide a description of your application to Kubernetes, it brings it to life.</li>
<li class="readable-text" data-hash="0d20f981aae9c14b653ac7585fc6ef2e" data-text-hash="0d20f981aae9c14b653ac7585fc6ef2e" id="234" refid="234">Kubernetes is like an operating system for the cluster. It abstracts the infrastructure and presents all computers in a data center as one large, contiguous deployment area.</li>
<li class="readable-text" data-hash="4b4169858c7e4859fd379591b6fd6512" data-text-hash="4b4169858c7e4859fd379591b6fd6512" id="235" refid="235">Microservice-based applications are more difficult to manage than monolithic applications. The more microservices you have, the more you need to automate their management with a system like Kubernetes.</li>
<li class="readable-text" data-hash="f10daa319211d2b852dc57192c6e96db" data-text-hash="f10daa319211d2b852dc57192c6e96db" id="236" refid="236">Kubernetes helps both development and operations teams to do what they do best. It frees them from mundane tasks and introduces a standard way of deploying applications both on-premises and in any cloud.</li>
<li class="readable-text" data-hash="1d215143b0abf24a6f290c5d0d7d7583" data-text-hash="1d215143b0abf24a6f290c5d0d7d7583" id="237" refid="237">Using Kubernetes allows developers to deploy applications without the help of system administrators. It reduces operational costs through better utilization of existing hardware, automatically adjusts your system to load fluctuations, and heals itself and the applications running on it.</li>
<li class="readable-text" data-hash="e0c9acf47d86f8c5609f1b0fce3610f3" data-text-hash="a39e8cbe1181a05a34ab38897d07fd0d" id="238" refid="238">A Kubernetes cluster consists of master and worker nodes. The master nodes run the <i>Control Plane</i>, which controls the entire cluster, while the worker nodes run the deployed applications or workloads, and therefore represent the <i>Workload Plane</i>.</li>
<li class="readable-text" data-hash="2414bf28158b1af2a5efb945216a5064" data-text-hash="2414bf28158b1af2a5efb945216a5064" id="239" refid="239">Using Kubernetes is simple, but managing it is hard. An inexperienced team should use a Kubernetes-as-a-Service offering instead of deploying Kubernetes by itself.</li>
</ul>
<div class="readable-text" data-hash="3434976ad406c2818d6b08ef19881428" data-text-hash="bd9a66299364eabe8f341a5e8a9a0041" id="240" refid="240">
<p>So far, you&#8217;ve only observed the ship from the pier. It&#8217;s time to come aboard. But before you leave the docks, you should inspect the shipping containers it&#8217;s carrying. You&#8217;ll do this next.</p>
</div></div>

        </body>
        
        